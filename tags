!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
E_ADD	lexer.hpp	/^		E_ADD = '+',$/;"	e	enum:Token::token_type
E_ADVANCE	lexer.hpp	/^			E_ADVANCE = 1$/;"	e	enum:parser_helper::token_advance_mode
E_DIV	lexer.hpp	/^		E_DIV = '\/',$/;"	e	enum:Token::token_type
E_EOF	lexer.hpp	/^		E_EOF = 6,$/;"	e	enum:Token::token_type
E_ERROR	lexer.hpp	/^		E_ERROR = 1,$/;"	e	enum:Token::token_type
E_ERR_NUMBER	lexer.hpp	/^		E_ERR_NUMBER = 3,$/;"	e	enum:Token::token_type
E_ERR_SFUNC	lexer.hpp	/^		E_ERR_SFUNC = 5,$/;"	e	enum:Token::token_type
E_ERR_STRING	lexer.hpp	/^		E_ERR_STRING = 4,$/;"	e	enum:Token::token_type
E_ERR_SYMBOL	lexer.hpp	/^		E_ERR_SYMBOL = 2, $/;"	e	enum:Token::token_type
E_HOLD	lexer.hpp	/^			E_HOLD = 0,$/;"	e	enum:parser_helper::token_advance_mode
E_LBRACKET	lexer.hpp	/^		E_LBRACKET = '(',$/;"	e	enum:Token::token_type
E_MOD	lexer.hpp	/^		E_MOD = '%',$/;"	e	enum:Token::token_type
E_MUL	lexer.hpp	/^		E_MUL = '*',$/;"	e	enum:Token::token_type
E_NONE	lexer.hpp	/^		E_NONE = 0,$/;"	e	enum:Token::token_type
E_NUMBER	lexer.hpp	/^		E_NUMBER = 7,$/;"	e	enum:Token::token_type
E_POW	lexer.hpp	/^		E_POW = '^',$/;"	e	enum:Token::token_type
E_RBRACKET	lexer.hpp	/^		E_RBRACKET = ')',$/;"	e	enum:Token::token_type
E_STRING	lexer.hpp	/^		E_STRING = 9,$/;"	e	enum:Token::token_type
E_SUB	lexer.hpp	/^		E_SUB = '-',$/;"	e	enum:Token::token_type
E_SYMBOL	lexer.hpp	/^		E_SYMBOL = 8,$/;"	e	enum:Token::token_type
Generator	lexer.hpp	/^		Generator():base_itr_(0), s_itr_(0), s_end_(0)$/;"	f	class:Generator
Generator	lexer.hpp	/^class Generator$/;"	c
LEXER_HPP	lexer.hpp	42;"	d
Token	lexer.hpp	/^	Token()$/;"	f	struct:Token
Token	lexer.hpp	/^struct Token$/;"	s
add_invalid	lexer.hpp	/^			void add_invalid(Token::token_type base, Token::token_type t) { invalid_comb_.insert(std::make_pair(base, t)); }$/;"	f	class:helper::sequence_validator
add_invalid_set1	lexer.cpp	/^void helper::sequence_validator::add_invalid_set1(token::token_type t)$/;"	f	class:helper::sequence_validator
add_replace	lexer.cpp	/^bool helper::symbol_replacer::add_replace(const std::string &target_symbol,$/;"	f	class:helper::symbol_replacer
advance_token	lexer.cpp	/^void parser_helper::advance_token(const token_advance_mode mode)$/;"	f	class:parser_helper
base_itr_	lexer.hpp	/^		const char *base_itr_;$/;"	m	class:Generator
begin	lexer.cpp	/^void Generator::begin()$/;"	f	class:Generator
cleanup_escapes	lexer.cpp	/^bool details::cleanup_escapes(std::string &s)$/;"	f	class:details
clear	lexer.cpp	/^void Generator::clear()$/;"	f	class:Generator
clear	lexer.cpp	/^void token::clear()$/;"	f	class:token
clear_errors	lexer.hpp	/^			void clear_errors() { return error_list_.clear(); }$/;"	f	class:helper::sequence_validator
comment_end	lexer.cpp	/^static bool comment_end(const char c0, const char c1, const int mode)$/;"	f	file:
comment_start	lexer.cpp	/^static bool comment_start(const char c0, const char c1, int &mode, int &incr)$/;"	f	file:
current_token	lexer.hpp	/^		const token_t &current_token() const { return current_token_; }$/;"	f	class:parser_helper
current_token_	lexer.hpp	/^		token_t current_token_;$/;"	m	class:parser_helper
details	lexer.hpp	/^namespace details$/;"	n
dump	lexer.cpp	/^void helper::dump(generator &generator)$/;"	f	class:helper
empty	lexer.cpp	/^bool Generator::empty() const$/;"	f	class:Generator
eof_token_	lexer.hpp	/^		token_t eof_token_;$/;"	m	class:Generator
error	lexer.cpp	/^std::pair<token,token> helper::sequence_validator::error(const std::size_t index)$/;"	f	class:helper::sequence_validator
error_count	lexer.hpp	/^			std::size_t error_count() { return error_list_.size(); }$/;"	f	class:helper::sequence_validator
error_list_	lexer.hpp	/^			std::deque<std::pair<Token, Token> > error_list_;$/;"	m	class:helper::sequence_validator
error_token_inserter	lexer.hpp	/^		token_inserter* error_token_inserter;$/;"	m	struct:helper::helper_assembly
error_token_joiner	lexer.hpp	/^		token_joiner*   error_token_joiner;$/;"	m	struct:helper::helper_assembly
error_token_modifier	lexer.hpp	/^		token_modifier* error_token_modifier;$/;"	m	struct:helper::helper_assembly
error_token_scanner	lexer.hpp	/^		token_scanner*  error_token_scanner;$/;"	m	struct:helper::helper_assembly
eval_expression	main.cpp	/^static int eval_expression(const std::string &expr, int value)$/;"	f	file:
evaluate	main.cpp	/^static int evaluate(const std::string &expr)$/;"	f	file:
finished	lexer.cpp	/^bool Generator::finished() const$/;"	f	class:Generator
generator_t	lexer.hpp	/^		typedef Generator generator_t;$/;"	t	class:parser_helper
helper	lexer.hpp	/^namespace helper$/;"	n
helper_assembly	lexer.hpp	/^	struct helper_assembly$/;"	s	namespace:helper
ilesscompare	lexer.hpp	/^	struct ilesscompare$/;"	s	namespace:details
imatch	lexer.cpp	/^bool details::imatch(const char c1, const char c2)$/;"	f	class:details
imatch	lexer.cpp	/^bool details::imatch(const std::string &s1, const std::string &s2)$/;"	f	class:details
init	lexer.cpp	/^bool parser_helper::init(const std::string &str)$/;"	f	class:parser_helper
insert	lexer.cpp	/^int helper::commutative_inserter::insert(const token &t0, const token &t1, token &new_token)$/;"	f	class:helper::commutative_inserter
invalid_bracket_check	lexer.cpp	/^bool helper::sequence_validator::invalid_bracket_check(token::token_type base, token::token_type t)$/;"	f	class:helper::sequence_validator
invalid_comb_	lexer.hpp	/^			set_t invalid_comb_;$/;"	m	class:helper::sequence_validator
is_bracket	lexer.cpp	/^bool details::is_bracket(const char c)$/;"	f	class:details
is_digit	lexer.cpp	/^bool details::is_digit(const char c)$/;"	f	class:details
is_end	lexer.hpp	/^		bool is_end(const char *itr) { return (s_end_ == itr); }$/;"	f	class:Generator
is_error	lexer.cpp	/^bool token::is_error() const$/;"	f	class:token
is_invalid	lexer.cpp	/^bool details::is_invalid(const char c)$/;"	f	class:details
is_left_bracket	lexer.cpp	/^bool details::is_left_bracket(const char c)$/;"	f	class:details
is_letter	lexer.cpp	/^bool details::is_letter(const char c)$/;"	f	class:details
is_letter_or_digit	lexer.cpp	/^bool details::is_letter_or_digit(const char c)$/;"	f	class:details
is_operator_char	lexer.cpp	/^bool details::is_operator_char(const char c)$/;"	f	class:details
is_right_bracket	lexer.cpp	/^bool details::is_right_bracket(const char c)$/;"	f	class:details
is_sign	lexer.cpp	/^bool details::is_sign(const char c)$/;"	f	class:details
is_whitespace	lexer.cpp	/^bool details::is_whitespace(const char c)$/;"	f	class:details
join	lexer.cpp	/^bool helper::operator_joiner::join(const token &t0, const token &t1, token &t)$/;"	f	class:helper::operator_joiner
lexer	lexer.hpp	/^		const generator_t &lexer() const { return lexer_; }$/;"	f	class:parser_helper
lexer	lexer.hpp	/^		generator_t &lexer() { return lexer_; }$/;"	f	class:parser_helper
lexer_	lexer.hpp	/^		generator_t lexer_;$/;"	m	class:parser_helper
main	main.cpp	/^int main(void)$/;"	f
modify	lexer.cpp	/^bool helper::symbol_replacer::modify(token &t)$/;"	f	class:helper::symbol_replacer
next_token	lexer.cpp	/^Generator::token_t &Generator::next_token()$/;"	f	class:Generator
next_token	lexer.hpp	/^		void next_token() { current_token_ = lexer_.next_token(); }$/;"	f	class:parser_helper
operator ()	lexer.cpp	/^bool details::ilesscompare::operator()(const std::string &s1, const std::string &s2) const$/;"	f	class:details::ilesscompare
operator ()	lexer.cpp	/^bool helper::bracket_checker::operator()(const token &t)$/;"	f	class:helper::bracket_checker
operator ()	lexer.cpp	/^bool helper::sequence_validator::operator()(const token& t0, const token& t1)$/;"	f	class:helper::sequence_validator
operator []	lexer.cpp	/^Generator::token_t &Generator::operator[](const std::size_t &index)$/;"	f	class:Generator
operator []	lexer.cpp	/^Generator::token_t Generator::operator[](const std::size_t &index) const$/;"	f	class:Generator
parser_helper	lexer.hpp	/^class parser_helper$/;"	c
peek_next_token	lexer.cpp	/^Generator::token_t &Generator::peek_next_token()$/;"	f	class:Generator
peek_token_is	lexer.hpp	/^		bool peek_token_is(const std::string &s) { return (details::imatch(lexer_.peek_next_token().value, s)); }$/;"	f	class:parser_helper
peek_token_is	lexer.hpp	/^		bool peek_token_is(const token_t::token_type &ttype) { return (lexer_.peek_next_token().type == ttype); }$/;"	f	class:parser_helper
position	lexer.hpp	/^	std::size_t position;$/;"	m	struct:Token
process	lexer.cpp	/^bool Generator::process(const std::string &str)$/;"	f	class:Generator
process	lexer.cpp	/^std::size_t token_inserter::process(generator &g)$/;"	f	class:token_inserter
process	lexer.cpp	/^std::size_t token_joiner::process(generator &g)$/;"	f	class:token_joiner
process	lexer.cpp	/^std::size_t token_modifier::process(generator &g)$/;"	f	class:token_modifier
process	lexer.cpp	/^std::size_t token_scanner::process(generator &g)$/;"	f	class:token_scanner
register_inserter	lexer.cpp	/^bool helper::helper_assembly::register_inserter(token_inserter *inserter)$/;"	f	class:helper::helper_assembly
register_joiner	lexer.cpp	/^bool helper::helper_assembly::register_joiner(token_joiner *joiner)$/;"	f	class:helper::helper_assembly
register_modifier	lexer.cpp	/^bool helper::helper_assembly::register_modifier(token_modifier *modifier)$/;"	f	class:helper::helper_assembly
register_scanner	lexer.cpp	/^bool helper::helper_assembly::register_scanner(token_scanner *scanner)$/;"	f	class:helper::helper_assembly
remaining	lexer.cpp	/^std::string Generator::remaining() const$/;"	f	class:Generator
remove	lexer.cpp	/^bool helper::symbol_replacer::remove(const std::string &target_symbol)$/;"	f	class:helper::symbol_replacer
reset	lexer.cpp	/^void helper::bracket_checker::reset()$/;"	f	class:helper::bracket_checker
restore	lexer.cpp	/^void Generator::restore()$/;"	f	class:Generator
result	lexer.hpp	/^			bool result() { return error_list_.empty(); }$/;"	f	class:helper::sequence_validator
run_inserters	lexer.cpp	/^bool helper::helper_assembly::run_inserters(generator &g)$/;"	f	class:helper::helper_assembly
run_joiners	lexer.cpp	/^bool helper::helper_assembly::run_joiners(generator &g)$/;"	f	class:helper::helper_assembly
run_modifiers	lexer.cpp	/^bool helper::helper_assembly::run_modifiers(generator &g)$/;"	f	class:helper::helper_assembly
run_scanners	lexer.cpp	/^bool helper::helper_assembly::run_scanners(generator &g)$/;"	f	class:helper::helper_assembly
s_end_	lexer.hpp	/^		const char *s_end_;$/;"	m	class:Generator
s_itr_	lexer.hpp	/^		const char *s_itr_;$/;"	m	class:Generator
scan_number	lexer.cpp	/^void Generator::scan_number()$/;"	f	class:Generator
scan_operator	lexer.cpp	/^void Generator::scan_operator()$/;"	f	class:Generator
scan_string	lexer.cpp	/^void Generator::scan_string()$/;"	f	class:Generator
scan_symbol	lexer.cpp	/^void Generator::scan_symbol()$/;"	f	class:Generator
scan_token	lexer.cpp	/^void Generator::scan_token()$/;"	f	class:Generator
sequence_validator	lexer.hpp	/^			sequence_validator()$/;"	f	class:helper::sequence_validator
sequence_validator	lexer.hpp	/^	class sequence_validator : public token_scanner$/;"	c	namespace:helper
set_error	lexer.cpp	/^token &token::set_error(const token_type et, const Iterator begin, const Iterator end, const Iterator base_begin)$/;"	f	class:token
set_general	lexer.cpp	/^token &token::set_general(const token_type tt, const Iterator begin, const Iterator end, const Iterator base_begin)$/;"	f	class:token
set_general	lexer.cpp	/^token& token::set_general(const token_type tt, const std::string &s, const std::size_t p)$/;"	f	class:token
set_t	lexer.hpp	/^			 typedef std::set<token_pair_t> set_t;$/;"	t	class:helper::sequence_validator
size	lexer.cpp	/^std::size_t Generator::size() const$/;"	f	class:Generator
skip_comments	lexer.cpp	/^void Generator::skip_comments(void)$/;"	f	class:Generator
skip_whitespace	lexer.cpp	/^void Generator::skip_whitespace(void)$/;"	f	class:Generator
store	lexer.cpp	/^void Generator::store()$/;"	f	class:Generator
store_token_itr_	lexer.hpp	/^		token_list_itr_t store_token_itr_;$/;"	m	class:Generator
to_str	lexer.cpp	/^std::string token::to_str(token_type t)$/;"	f	class:token
token_advance_mode	lexer.hpp	/^		enum token_advance_mode$/;"	g	class:parser_helper
token_inserter_list	lexer.hpp	/^		std::deque<token_inserter*> token_inserter_list;$/;"	m	struct:helper::helper_assembly
token_is	lexer.cpp	/^bool parser_helper::token_is(const token_t::token_type &ttype, const std::string &value, const token_advance_mode mode)$/;"	f	class:parser_helper
token_is	lexer.cpp	/^bool parser_helper::token_is(const token_t::token_type &ttype, const token_advance_mode mode)$/;"	f	class:parser_helper
token_is_then_assign	lexer.cpp	/^bool parser_helper::token_is_then_assign(const token_t::token_type &ttype,$/;"	f	class:parser_helper
token_is_then_assign	lexer.cpp	/^bool parser_helper::token_is_then_assign(const token_t::token_type& ttype,$/;"	f	class:parser_helper
token_itr_	lexer.hpp	/^		token_list_itr_t token_itr_;$/;"	m	class:Generator
token_joiner_list	lexer.hpp	/^		std::deque<token_joiner*>   token_joiner_list;$/;"	m	struct:helper::helper_assembly
token_list_	lexer.hpp	/^		token_list_t token_list_;$/;"	m	class:Generator
token_list_itr_t	lexer.hpp	/^		typedef std::deque<token_t>::iterator token_list_itr_t;$/;"	t	class:Generator
token_list_t	lexer.hpp	/^		typedef std::deque<token_t> token_list_t;$/;"	t	class:Generator
token_modifier_list	lexer.hpp	/^		std::deque<token_modifier*> token_modifier_list;$/;"	m	struct:helper::helper_assembly
token_pair_t	lexer.hpp	/^			 typedef std::pair<Token::token_type,Token::token_type> token_pair_t;$/;"	t	class:helper::sequence_validator
token_scanner_list	lexer.hpp	/^		std::deque<token_scanner*>  token_scanner_list;$/;"	m	struct:helper::helper_assembly
token_t	lexer.hpp	/^		typedef Token token_t;$/;"	t	class:Generator
token_t	lexer.hpp	/^		typedef Token token_t;$/;"	t	class:parser_helper
token_type	lexer.hpp	/^	enum token_type$/;"	g	struct:Token
type	lexer.hpp	/^	token_type type;$/;"	m	struct:Token
value	lexer.hpp	/^	std::string value;$/;"	m	struct:Token
